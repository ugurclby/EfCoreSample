Add-Migration migration_name    = > migration ekler
Update-Database                 = > son oluşan migration ı db ye yansıtır.
Update-Database migration_name  = > Eski migration a dönmeyi sağlar. 
Remove-migration                = > son oluşan migration db ye eklenmediyse siler.
Remove-migration migration_name = > migration_name i db ye eklenmediyse siler.
script-migration                = > Migration dosyalarında yapılan işlemleri sql e döker.

--------------------------------------------

State Codes : _context.Entry(entityclass).State

UnChanged = > Db den tablo çekildiği zaman ki durumu ya da savechanges metodu çalıştığında state unchanged olur.
Detached  = > Entity sınıfı üzerinde bir değişiklik yapıp state sorguladığımız zaman döner. Henüz izlenmeyen durumlar. Sildikten sonrada olur.
              Ef ye bu sınıfı artık izleme dediğimiz nokta da olur.
Added     = > Detached olan bir sınıf için add metodu çalışırsa state added olur 
Modified  = > Db den çekilen bir tablo üzerinde değişiklik yapıldığında state modified olur.
Deleted   = > Remove metodu sonrası state deleted olur.

--------------------------------------------

context üzerinden bir entity çekildikten sonra üzerinde bir düzenleme yapılırsa update işlemini çağırmadan 
savechanges metodu çalıştırıldığında otomatik olarak update işlemi yapılır. Gereksiz yere update işlemi çağırılmış olur.

--------------------------------------------

Tablo Configration ayarları : 

3 yöntem var . 

Data annotations Attributes = > Entity class ve propertyler üzerine uygulanan annotations attribute'ler ile yapılır.
                                [Table("Products")] , [Column("ProductName")] , [Key] gibi.     

Fluent Api                  = > Dbcontext içerisindeki OnModelCreating metodu altında ToTable , HasColumnName , HasKey gibi özellikler kullanılarak yapılır.
                                modelBuilder.Entity<Product>().ToTable("Products") , modelBuilder.Entity<Product>().Property(p => p.ProductName).HasColumnName("ProductName") gibi.

Convensions                 = > Tüm entityler ef core'un anlayacağı şekilde tanımlanırsa ekstra bir şey yapmaya gerek kalmaz.
                                tablo : DbSet<Product> , Kolon : PropertyName , Primary Key : Id ve ProductId gibi.

*** Hem Data annotations hemde Fluent Api kullanılabilir. Fluent api data annotations ı ezer. Validasyon için kullanılmış olur.

--------------------------------------------

Tablo İlişkileri : Bu işin best practice i Convensions dır. Tamamen doğru isimlendirmeler üzerinden ilerlemek gerekir.
İsimlendirmelerin eksik kaldığı noktada Fluent Api kullanılır.
Convensions : Ef core un default davranışı

one to many = > 

Convensions : İlişkili entityler arasında bir navigation property tanımlanmışsa ef core ilişkiyi otomatik olarak algılar.
               Product sınıfında Category sınıfına ait bir navigation property tanımlanmışsa ef core ilişkiyi otomatik olarak algılar.

Fluent Api  : modelBuilder.Entity<Catalog>().HasMany(x => x.Products).WithOne(x => x.Catalog).HasForeignKey(x => x.CatalogId);          

Data annotations Attributes : [ForeignKey("CatalogId")]

shadow property : foreing key alanın entity içerisinde olmaması durumunda ef core tarafından oluşturulan property dir. 
Detay tabloya direkt insert işlemi sadece master tablo üzerinden yapılması gereken durumlarda kullanılır.

one to one = > 

Convensions : İlişki kurulacak 2 entity arasında ikinise de navigation property tanımlaması yapılır. Parent tabloya child tablosunun 
id kolonu verilmez. Child tablosuna parent tablosunun id kolonu verilir.

Fluent Api  :         modelBuilder.Entity<Product>().HasOne(x => x.ProductFeature).WithOne(x => x.Product).HasForeignKey<ProductFeature>(x => x.ProductId);

Data annotations Attributes : [ForeignKey("ProductId")], Hangisinin parent hangisinin child olduğunu belirtmek için ForeignKey ataması yapılmalıdır.

many to many = > 

Convensions : İlişki kurulacak 2 entity arasında ikinise de navigation property tanımlaması yapılır. İki entity de List tipinde bir property tanımlanır. ef core otomatik olarak ilişkiyi algılar. Ara bir tablo oluşturur.

Fluent Api  :         modelBuilder.Entity<Teacher>().HasMany(x => x.Students).WithMany(x => x.Teachers).UsingEntity<Dictionary<string, object>>(
            "TeacherStudent",
            x => x.HasOne<Student>().WithMany().HasForeignKey("Student_Id"),
            x => x.HasOne<Teacher>().WithMany().HasForeignKey("Teacher_Id")
            );

--------------------------------------------

Delete Behavior :

Cascade : Parent tablo üzerinde bir silme işlemi yapıldığında child tablolar üzerinde de silme işlemi yapar.
Restrict : Parent tablo üzerinde bir silme işlemi yapıldığında child tablosunda bağlı verisi varsa silme işlemi yapmaz ve hata verir.
SetNull : Parent tablo üzerinde bir silme işlemi yapıldığında child tablolar üzerinde parent tabloya ait alanlar null yapılır.
NoAction : Parent tablo üzerinde bir silme işlemi yapıldığında child tablolar üzerinde silme işlemi yapmaz.

--------------------------------------------

Database Generated Attribute :
Computed : Ef core ilgili alanı hem insert hemde update işlemlerinde dahil etme.
     modelBuilder.Entity<Product>().Property(x => x.PriceKdv).ValueGeneratedOnAddOrUpdate();
Identity : Ef core sadece insert işleminde kullan update işleminde ilgili alanı dahil etme.
    modelBuilder.Entity<Product>().Property(x => x.PriceKdv).ValueGeneratedOnAdd();
None : Veritabanı tarafından otomatik değer üretme özelliğini kapatır.
    modelBuilder.Entity<Product>().Property(x => x.PriceKdv).ValueGeneratedNever();

--------------------------------------------

Related Data Load :

Eager Loading : Include metodu ile ilişkili tabloları birlikte çeker.
    var products = _context.Products.Include(x => x.ProductFeature).ToList();
Explicit Loading : İhtiyaç anında ilgili navigation property üzerinden tablo çekme işlemi
    bire çok ilişki varsa :
        var product = _context.Products.FirstOrDefault();
        _context.Entry(product).Collection(x => x.ProductFeature).Load();
    bire bir ilişki varsa : 
    var product = _context.Products.FirstOrDefault();
        _context.Entry(product).Reference(x => x.ProductFeature).Load();
Lazy Loading : Explicit Loading ile yaptığı işlem aynı sadece otomatik olarak yapar. Load etmeye gerek kalmadan direkt 
catalog.products dediğimiz an kayıtları çeker. Bu özelliği aktif etmek gerekir. İkiside tekrar db tarafına gidip select çeker.
Lazy loading yapmak için Microsoft.EntityFrameworkCore.Proxies yüklenmenlidir. Navigation property lerin virtual olması gerekir.
optionsBuilder.UseLazyLoadingProxies().UseSqlServer(DbContextInitializer.Configuration.GetConnectionString("DefaultConnection"));

--------------------------------------------

İnheritance :

TPH(Table Per Hierarchy) : 
2 türlü ele alınır. 
1- Base bir sınıf belirlenir. O sınıf üzerinden farklı sınıflar türetilir. Onmodelcreating metodu içinde base tablo dbset olarak verilmezse ef core db de base tabloyu oluşturmaz.
alt sınıflara atanan kolonlar ile birlikte yeni tabloları oluşturur.
2- Eğer base sınıf dbcontext sınıfı içinde dbset olarak tanımlanırsa ,tüm entitylerin tek bir tablo üzerinde tutulur ve Discriminator adında bir kolon oluşturur.  
tüm kayıtları tip ile ayırt eder. Discriminator kolonu string tipindedir. Discriminator kolonu db de oluşur ve ef core tarafından yönetilir.
Eğer süreç ef core bırakılmayıp kolon ismi ve hangi tabloların hiyerarşik olduğu belirtilmek istenirse Fluent Api kullanılır.
        modelBuilder.Entity<Vehicle>().HasDiscriminator<string>("VehicleType")
            .HasValue<Vehicle>("Vehicle")
            .HasValue<Bike>("Bike")
            .HasValue<SportsCar>("SportsCar");

TPT(Table Per Type) :
Base sınıf ve alt sınıfların ayrı ayrı tabloları oluşturulur. Base sınıf dbset olarak tanımlanır. Alt sınıflar dbset olarak tanımlanmaz.
Bunu yapabilmek için onmodelcreating metodu içinde her entity totable olarak tanımlanır. Ef core bunları db tarafında çoka çok ilişki üzerinden
bağlar. VEriler vehicle tablosunda durur. 
    modelBuilder.Entity<Vehicle>().ToTable("Vehicles");
    modelBuilder.Entity<Bike>().ToTable("Bikes");
    modelBuilder.Entity<SportsCar>().ToTable("SportsCars");